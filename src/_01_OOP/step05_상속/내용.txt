- 상속과 메모리 구조
    : 상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성된다.
    : 상속 관계의 객체를 호출할 때, 대상 타입을 정해야 한다. 이때 호출자의 타읍을 통해 대상 타입을 찾는다.
    : 현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행한다.
      기능을 찾지 못하면 컴파일 오류가 발생한다.

- 오버로딩
    : 메서드 이름이 같고 매개변수가 다른 메서드를 여러개 정의하는 것

- 오버라이딩
    : 하위 클래스에서 상위 클래스의 메서드를 재정의하는 것
      단순히 해석하면 무언가를 넘어서 타는 것을 말한다. 자식의 새로운 기능이 부모의 기존 기능을 넘어 타서 기존 기능을 새로운 기능으로 덮어버리는 것이다.

- 오버라이딩 조건
    : 메서드의 이름과 매개변수의 타입, 순서, 개수가 같아야 한다.
    : 반환 타입이 같거나 하위 클래스의 타입이어야 한다.
    : 상위 클래스의 메서드보다 더 제한적이어서는 안 된다.
    : 상위 클래스의 메서드보다 더 많은 체크 예외를 throws로 선언할 수 없다.
    : static, final, private 키워드가 붙은 메서드는 오버라이딩 될 수 없다.
        > static은 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이딩이 의미가 없다.
          쉽게 말해 그냥 클래스 이름을 통해 필요한 곳에 직접 접근하면 된다.
        > final 메서드는 재정의를 금지한다.
    : 생성자는 오버라이딩 할 수 없다.

- 오버라이딩과 메모리 구조
    : 자식이 부모의 기능을 오버라이딩 했으면 자식 타입에 그 기능이 생성된 상태이다.
      이때 자식 참조 변수로 자식 인스턴스에 접근해서 오버라이딩한 기능을 호출한다면 자식 타입에서 그 기능을 찾을 것이기 때문에 부모 타입을 찾지 않는다.

- 접근제어자와 메모리 구조
    : 자식 참조변수로 자식 인스턴스에 접근할 때 찾으려는 기능이 본인 타입에 없으면 이때 접근 제어자가 영향을 준다.
      인스턴스 내부에는 자식과 부모가 구분되어 있기 때문이다.
      결국 자식 타입에서 자식 인스턴스 내부에 있는 부모 타입의 기능을 호출할 때 부모 입장에서 보면 외부에서 호출한 것과 같다.

- super 생성자
    : 상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.